#!/usr/bin/env python3
# Copyright 2019 Belma Turkovic
# TU Delft Embedded and Networked Systems Group.
# NOTICE: THIS FILE IS BASED ON https://github.com/p4lang/tutorials/tree/master/exercises/p4runtime, BUT WAS MODIFIED UNDER COMPLIANCE
# WITH THE APACHE 2.0 LICENCE FROM THE ORIGINAL WORK.

# ============================================================================
# P4Runtime Controller
# This controller manages P4 switches via the P4Runtime API, handling packet
# forwarding, table configuration, and host discovery through MAC learning.
# ============================================================================

import argparse
from threading import Thread
import grpc
import os
import sys
from time import sleep
import json

# Scapy imports for packet parsing and construction
from scapy.all import (
    Ether,
)

# Flask imports for HTTP server
from flask import Flask, jsonify

# Import P4Runtime library from parent utils directory
# These libraries provide utilities for P4 switch interaction and protobuf support
sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), "../util/"))
sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), "../util/lib/"))
import util.lib.p4_cli.bmv2 as bmv2
from util.lib.p4_cli.switch import ShutdownAllSwitchConnections
from util.lib.p4_cli.convert import encodeNum
import util.lib.p4_cli.helper as helper

# Flask imports for HTTP server to expose controller state
from flask import Flask, jsonify


# Initialize Flask app for HTTP interface
app = Flask(__name__)

# Global table to store learned source MAC addresses
smac_table = []

# ============================================================================
# HTTP API Endpoints
# ============================================================================

@app.route('/api/get_hosts', methods=['GET'])
def get_hosts():
    """
    HTTP endpoint to retrieve all discovered hosts.
    Returns a JSON object containing the list of MAC addresses and count.
    """
    global smac_table
    return jsonify({
        'hosts': smac_table,
        'count': len(smac_table)
    })


# ============================================================================
# Utility Functions
# ============================================================================

def printGrpcError(e):
    """
    Format and print gRPC errors with detailed information.
    Includes error message, status code, and file/line number where error occurred.
    
    Args:
        e: The gRPC exception to format
    """
    print("gRPC Error:", e.details(), end="")
    status_code = e.code()
    print("(%s)" % status_code.name, end="")
    traceback = sys.exc_info()[2]
    print("[%s:%d]" % (traceback.tb_frame.f_code.co_filename, traceback.tb_lineno))

def run_http_server(port=5000):
    """
    Run the Flask HTTP server for exposing controller state.
    
    Args:
        port (int): The port number for the HTTP server (default: 5000)
    """
    app.run(host='0.0.0.0', port=port, debug=False, use_reloader=False)


# Start HTTP server in a separate daemon thread to avoid blocking main thread
# This allows the HTTP API to run concurrently with the main controller logic
http_thread = Thread(target=run_http_server, args=(8080,), daemon=True)
http_thread.start()
print("HTTP server started on http://0.0.0.0:8080")



# ============================================================================
# Main Controller Logic
# ============================================================================

def main(p4info_file_path, bmv2_file_path):
    """
    Main controller function that manages P4Runtime switch communication.
    
    This function:
    1. Establishes a connection to the P4 switch
    2. Installs the P4 program on the switch
    3. Configures forwarding rules and multicast groups
    4. Handles incoming packets and performs MAC learning
    
    Args:
        p4info_file_path (str): Path to the p4info.txt file generated by p4c
        bmv2_file_path (str): Path to the bmv2.json file generated by p4c
    """
    
    # Create P4InfoHelper to convert table/field names to integers for gRPC API
    # This is necessary because the P4Runtime API works with numeric identifiers
    p4info_helper = helper.P4InfoHelper(p4info_file_path)

    try:
        # Create a switch connection object for s1
        # This object provides a P4Runtime gRPC connection to the switch
        # proto_dump_file logs all P4Runtime messages for debugging purposes
        s1 = bmv2.Bmv2SwitchConnection(
            name="s1",
            address="127.0.0.1:50001",
            device_id=1,
            proto_dump_file="p4runtime.log",
        )

        # ====================================================================
        # Step 1: Establish master arbitration with the switch
        # ====================================================================
        # This establishes the controller as the master for the switch.
        # This is required by P4Runtime before performing any write operations.
        # Only one master controller can manage a switch at a time.
        MasterArbitrationUpdate = s1.MasterArbitrationUpdate()
        print(MasterArbitrationUpdate)
        if MasterArbitrationUpdate == None:
            print("Failed to establish the connection")

        # ====================================================================
        # Step 2: Install the P4 program on the switch
        # ====================================================================
        # This sends the compiled P4 program (p4info + bmv2 binary) to the switch
        # The switch will use this program for all packet processing logic
        try:
            s1.SetForwardingPipelineConfig(
                p4info=p4info_helper.p4info, bmv2_json_file_path=bmv2_file_path
            )
            print("Installed P4 Program using SetForwardingPipelineConfig on s1")
        except Exception as e:
            print("Forwarding Pipeline added.")
            print(e)

        # ====================================================================
        # Step 3: Configure multicast group entries
        # ====================================================================
        # Multicast groups allow a single packet to be replicated to multiple ports
        # Multicast group ID 1: all ports (used for broadcasting)


        # ====================================================================
        # Main event loop
        # ====================================================================
        while True:
            # Step 4: Read PacketIn messages from the switch
            # PacketIn messages contain packets that require CPU processing

            # Step 5: Parse Ethernet frame using Scapy and PacketIn metadata
            # Extract source/destination MAC and other packet information

            # Step 6: Create table entries for dmac and smac lookup tables
            # Perform MAC learning based on incoming packet source address

            # Step 7: Create PacketOut message and send packet back to switch
            # Forward learned packets directly through switch ports

            sleep(1)   # Remove this line once PacketIn handling is implemented
    except KeyboardInterrupt:
        print(" Shutting down.")
    except grpc.RpcError as e:
        # Handle gRPC errors (connection issues, API errors, etc.)
        printGrpcError(e)

    # Close all switch connections and clean up resources
    ShutdownAllSwitchConnections()


# ============================================================================
# Entry Point
# ============================================================================

if __name__ == "__main__":
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description="P4Runtime Controller")
    parser.add_argument(
        "--p4info",
        help="p4info proto in text format from p4c",
        type=str,
        action="store",
        required=False,
        default="./p4src/build/p4info.txt",
    )
    parser.add_argument(
        "--bmv2-json",
        help="BMv2 JSON file from p4c",
        type=str,
        action="store",
        required=False,
        default="./p4src/build/bmv2.json",
    )
    args = parser.parse_args()

    # Validate that required input files exist
    if not os.path.exists(args.p4info):
        parser.print_help()
        print("\np4info file %s not found!" % args.p4info)
        parser.exit(1)
    if not os.path.exists(args.bmv2_json):
        parser.print_help()
        print("\nBMv2 JSON file %s not found!" % args.bmv2_json)
        parser.exit(2)
    
    # Start the main controller with the provided configuration files
    main(args.p4info, args.bmv2_json)